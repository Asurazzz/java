任何一个类被加载，必须加载这个类的静态代码块

同时如果存在父子关系的时候，调用子类的构造方法，同时子类的构造方法，在最顶部会调用super()也就是父类的构造方法，一般这个是被省略的

public Son() {
        super();
        System.out.println("我是儿子构造");
}
所以在子类初始化之前，还需要调用父类构造，所以父类需要加载进内存，也就是从父到子，静态执行，并且只加载一次
我是父亲静态代码块
我是儿子静态代码块

然后父类在进行实例化，在调用构造方法之前，需要调用本类的代码块
我是父亲代码块
我是父亲构造

最后父类初始化成功后，在调用子类的
我是儿子代码块
我是儿子构造

在执行第二次的 new Son()的时候，因为该类已经被装载在内存中了，因此静态代码块不需要执行，我们只需要从父到子执行即可
我是父亲代码块
我是父亲构造
我是儿子代码块
我是儿子构造


同理在执行new Father()的时候也是一样的，只需要执行Father的实例化

我是父亲代码块
我是父亲构造